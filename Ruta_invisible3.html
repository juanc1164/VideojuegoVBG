<!DOCTYPE html>
<html lang="es">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corredor de Obst치culos</title>
    
<script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos espec칤ficos para el canvas */
        #gameCanvas {
            border: 4px solid #333;
            border-radius: 12px;
            /* Deshabilita acciones t치ctiles predeterminadas (como el scroll) dentro del canvas */
            touch-action: manipulation; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
            background-color: #2563eb; /* Fondo azul oscuro, simulando una carretera o espacio */
        }
        /* Estilo para el spinner de carga */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .spinner {
            /* Uso de tailwind classes + animaci칩n CSS nativa */
            display: inline-block;
            width: 3rem; 
            height: 3rem; 
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }
        /* Estilo para asegurar que la fuente Arial Black se vea correctamente */
        .arial-black {
             font-family: 'Arial Black', Gadget, sans-serif;
        }

        /* Estilo para la animaci칩n de celebraci칩n (Victory Screen) */
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {transform: translateY(0);}
            40% {transform: translateY(-5px);}
            60% {transform: translateY(-3px);}
        }
        .celebration-icon {
            animation: bounce 0.8s infinite;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4 font-sans">

    
<div id="gameContainer" class="bg-slate-700 p-6 rounded-2xl shadow-2xl">
        
<canvas id="gameCanvas" width="300" height="500"></canvas>
    </div>

    <script>
        // Configuraci칩n de las variables globales del Canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- CARGA DE IM츼GENES DE PERSONAJES Y OBST츼CULOS (MODIFICADO) ---
        const hombreImg = new Image();
        hombreImg.src = 'Hombre.png'; // Archivo en la misma ubicaci칩n
        
        const mujerImg = new Image();
        mujerImg.src = 'Mujer.png'; // Archivo en la misma ubicaci칩n
        
        // ** NUEVAS IM츼GENES DE OBST츼CULOS **
        const obstImages = [
            null, // Se usa el 칤ndice 1, 2, 3, 4
            loadImage('Obst1.png'), // M치s angosto
            loadImage('Obst2.png'),
            loadImage('Obst3.png'),
            loadImage('Obst4.png')  // M치s grande
        ];
        
        // Funci칩n auxiliar para cargar im치genes y a침adir el handler de carga/error
        function loadImage(src) {
            const img = new Image();
            img.src = src;
            img.onload = imageLoaded;
            img.onerror = () => {
                console.error(`Error al cargar ${src}. Usando fallback.`);
                imageLoaded();
            };
            return img;
        }

        // --- GESTI칍N DE CARGA DE IM츼GENES (FIX PARA EL ERROR) ---
        let imagesLoadedCount = 0;
        // Total de 2 personajes + 4 obst치culos = 6 im치genes a cargar
        const totalImagesToLoad = 6; 

        // Cambiamos el estado inicial a 'loading'
        let gameState = 'loading'; 

        // Funci칩n que se ejecuta cuando una imagen termina de cargar
        function imageLoaded() {
            imagesLoadedCount++;
            if (imagesLoadedCount === totalImagesToLoad) {
                // Cuando todas las im치genes han cargado, pasamos a la pantalla de selecci칩n
                gameState = 'selection'; 
                console.log("Todas las im치genes cargadas. Iniciando selecci칩n.");
            }
        }

        // Asignamos los handlers de carga y error para los personajes (ya asignados en loadImage para obst치culos)
        hombreImg.onload = imageLoaded;
        mujerImg.onload = imageLoaded;
        
        hombreImg.onerror = () => { 
            console.error("Error al cargar Hombre.png. Usando fallback."); 
            imageLoaded();
        };
        mujerImg.onerror = () => { 
            console.error("Error al cargar Mujer.png. Usando fallback."); 
            imageLoaded();
        };
        // ------------------------------------------------

        
        // --- Variables de Configuraci칩n del Juego ---
        let player = {
            x: canvas.width / 2 - 15, // Posici칩n central inicial
            y: canvas.height - 70, // Posici칩n fija cerca de la parte inferior
            w: 30, // Ancho del cuerpo (colisi칩n)
            h: 50, // Alto total de la figura (colisi칩n)
            speedX: 3.8, // Velocidad de movimiento horizontal
            image: null // Referencia a la imagen seleccionada (hombreImg o mujerImg)
        };

        let obstacles = [];
        let score = 0;
        let frame = 0;
        let obstacleSpeed = 1.5; // Velocidad de ca칤da de obst치culos (avance del juego)
        let gameSpeedIncrease = 0; // Velocidad de aumento de dificultad establecida a 0 (velocidad constante)
        
        // Estado del personaje seleccionado: 'man' o 'woman'
        let selectedCharacter = null; 
        
        // Variables para el movimiento continuo
        let isMovingLeft = false;
        let isMovingRight = false;
        
        // ** Variable: Almacena el mensaje social elegido al perder el juego. **
        let gameOverMessage = null; 

        // Constante para el espaciamiento de obst치culos
        const OBSTACLE_GENERATION_RATE = 150; 

        // Ancho de los "pasillos" laterales para las sillas (act칰an como paredes)
        const SIDE_AISLE_WIDTH = 40; 
        // Color de las sillas
        const CHAIR_COLOR = '#dc2626'; // Rojo (red-600)
        // Color del interior del vag칩n (paredes detr치s de las sillas)
        const VAGON_COLOR = '#4b5568'; // Gris oscuro (gray-700)
        // Color del piso/techo
        const FLOOR_CEILING_COLOR = '#374151'; // Gris muy oscuro (gray-800)
        // Color del pasillo central (치rea jugable)
        const AISLE_COLOR = '#d1d5db'; // Gris claro (gray-300)

        // Posiciones de los botones de selecci칩n
        let selectionButtons = {
            man: { x: 0, y: 0, w: 120, h: 50 },
            woman: { x: 0, y: 0, w: 120, h: 50 }
        };
        
        // Posiciones del bot칩n de Reintentar (para detecci칩n de clic)
        let retryBtn = {
            w: 180, 
            h: 50,  
            x: 0, 
            y: 0, 
            w2: 180, // Ancho para el segundo bot칩n
            h2: 50,  // Alto para el segundo bot칩n
            x2: 0, // Posici칩n para el segundo bot칩n
            y2: 0, // Posici칩n para el segundo bot칩n
        };
        
        // --- CONFIGURACI칍N: Mensajes Sociales Aleatorios (SCORE < 20) ---
        // Cada elemento del array contiene un sub-array de dos l칤neas de texto.
        const SOCIAL_MESSAGES = [
            // MENSAJE 1
            [
                'Para muchas mujeres esquivar obst치culos',
                'en el transporte p칰blico es su d칤a a d칤a.'
            ],
            // MENSAJE 2
            [
                '춰La violencia en el transporte no es juego!',
                'Ayuda a crear una "Ruta Invisible" solo aqu칤.'
            ],
            // MENSAJE 3
            [
                'El acoso y la discriminaci칩n afectan a miles.',
                'S칠 parte del cambio, denuncia y apoya.'
            ]
        ];
        // ----------------------------------------------------------------------


        // --- Funciones de Dibujo del Corredor (USA LA IMAGEN ASIGNADA EN player.image) ---
        
        // Funci칩n gen칠rica para dibujar la imagen (o el fallback)
        function drawPlayerImage(image, fallbackType) {
             // Si la imagen ya carg칩, se dibuja. Si no, se usa un fallback visual.
             if (image && image.complete) {
                ctx.drawImage(image, player.x, player.y, player.w, player.h);
            } else {
                // Fallback: Si no hay imagen, dibujamos la forma predeterminada
                if (fallbackType === 'man') {
                    // Fallback: Cuadrado azul si la imagen no est치 disponible
                    ctx.fillStyle = '#3b82f6'; 
                    ctx.fillRect(player.x, player.y, player.w, player.h);
                } else if (fallbackType === 'woman') {
                    // Fallback: Tri치ngulo rosado si la imagen no est치 disponible
                    ctx.fillStyle = '#ff69b4'; 
                    ctx.beginPath();
                    ctx.moveTo(player.x, player.y + player.h); 
                    ctx.lineTo(player.x + player.w / 2, player.y);
                    ctx.lineTo(player.x + player.w, player.y + player.h);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        function drawPlayer() {
            // Sombra para el personaje
            ctx.shadowColor = '#b91c1c'; // Sombra roja oscura
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            if (selectedCharacter === 'man') {
                drawPlayerImage(hombreImg, 'man');
            } else if (selectedCharacter === 'woman') {
                drawPlayerImage(mujerImg, 'woman');
            }
            
            // Restablecer la sombra
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        
        // --- Resto de Funciones de Dibujo ---

        // ** FUNCI칍N drawObstacles MODIFICADA PARA USAR IM츼GENES **
        function drawObstacles() {
            for (let i = 0; i < obstacles.length; i++) {
                let obs = obstacles[i];
                let obsImage = obstImages[obs.imageIndex]; // Obtener la imagen seg칰n el 칤ndice

                // Dibuja la imagen del obst치culo si est치 cargada
                if (obsImage && obsImage.complete) {
                    // Dibuja la imagen para cubrir el 치rea del obst치culo (obs.x, obs.y, obs.w, obs.h)
                    ctx.drawImage(obsImage, obs.x, obs.y, obs.w, obs.h);
                } else {
                    // Fallback: Si no hay imagen, dibuja un simple rect치ngulo rojo
                    ctx.fillStyle = '#ef4444'; // Rojo (red-500)
                    ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                    ctx.strokeStyle = 'black';
                    ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
                }
            }
        }
        // ** FIN DE MODIFICACI칍N **

        function drawScore() {
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.font = 'bold 36px sans-serif';
            ctx.textAlign = 'left';
            
            ctx.strokeText(score, 15, 45);
            ctx.fillText(score, 15, 45);
        }
        
        // Funci칩n de dibujo de mensajes mejorada con fuente legible (Arial Black por defecto)
        function drawMessage(text, yOffset, fontSize = 24, fontStyle = `'Arial Black', Gadget, sans-serif`, fillStyle = 'white', strokeStyle = '#333') {
            ctx.fillStyle = fillStyle;
            ctx.strokeStyle = strokeStyle;
            ctx.lineWidth = 4;
            ctx.font = `bold ${fontSize}px ${fontStyle}`; 
            ctx.textAlign = 'center';

            ctx.strokeText(text, canvas.width / 2, canvas.height / 2 + yOffset);
            ctx.fillText(text, canvas.width / 2, canvas.height / 2 + yOffset);
        }
        
        // Funci칩n de dibujo de botones
        function drawButton(text, x, y, w, h, bgColor, textColor, fontSize = 24) { // Fuente ajustada a 24px
             // Dibujar el fondo del bot칩n (con esquinas redondeadas)
            ctx.fillStyle = bgColor;
            const radius = 8;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + w - radius, y);
            ctx.arcTo(x + w, y, x + w, y + radius, radius);
            ctx.lineTo(x + w, y + h - radius);
            ctx.arcTo(x + w, y + h, x + w - radius, y + h, radius);
            ctx.lineTo(x + radius, y + h);
            ctx.arcTo(x, y + h, x, y + h - radius, radius);
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);
            ctx.fill();

            // Dibujar el texto del bot칩n
            ctx.fillStyle = textColor;
            ctx.strokeStyle = 'rgba(0,0,0,0.5)';
            ctx.lineWidth = 1;
            ctx.font = `bold ${fontSize}px Arial, sans-serif`;
            ctx.textAlign = 'center';
            const textY = y + h / 2 + fontSize / 3.5; // Ajuste para centrado vertical
            ctx.strokeText(text, x + w / 2, textY);
            ctx.fillText(text, x + w / 2, textY);
        }
        
        // PANTALLA DE CARGA (NUEVA)
        function drawLoadingScreen() {
            ctx.fillStyle = VAGON_COLOR; 
            ctx.fillRect(0, 0, canvas.width, canvas.height); 

            // Spinner (usando la clase CSS definida)
            // No podemos dibujar el elemento div/CSS directamente en canvas,
            // pero podemos simular la animaci칩n del spinner dibujando un c칤rculo giratorio.
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(frame * 0.1); // Rotaci칩n basada en el frame
            
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 1.5, false); // Arco de 3/4 de c칤rculo
            ctx.lineWidth = 6;
            ctx.strokeStyle = '#fff'; // Color de la l칤nea principal
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(0, 0, 25, Math.PI * 1.5, Math.PI * 2, false); // Arco del cuarto restante (m치s tenue)
            ctx.lineWidth = 6;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; // Color de la l칤nea de fondo
            ctx.stroke();
            
            ctx.restore();

            // Mensaje
            drawMessage('Cargando im치genes...', 50, 24, `'Arial Black', Gadget, sans-serif`, 'white', '#1f2937');
            // Dibuja el frame para que el spinner anime
            frame++; 
        }

        // PANTALLA DE SELECCI칍N DE PERSONAJE
        function drawSelectionScreen() {
            // Fondo del pasillo
            ctx.fillStyle = AISLE_COLOR; 
            ctx.fillRect(0, 0, canvas.width, canvas.height); 
            
            // --- T칈TULO "RUTA INVISIBLE" ---
            const titleFillStyle = '#1f2937'; // Gris oscuro/negro
            const titleStrokeStyle = 'white'; // Contorno blanco
            const titleFont = `'Arial Black', Gadget, sans-serif`;
            const titleSize = 42; // Tama침o grande

            // 1. RUTA
            drawMessage('RUTA', -160, titleSize, titleFont, titleFillStyle, titleStrokeStyle); 
            // 2. INVISIBLE
            drawMessage('INVISIBLE', -120, titleSize, titleFont, titleFillStyle, titleStrokeStyle); 


            // 3. Mensaje de selecci칩n
            drawMessage('Elija su personaje:', -30, 20, `'Arial Black', Gadget, sans-serif`, '#1f2937', 'white'); // Posici칩n ajustada
            
            // Posiciones de los botones
            const btnMargin = 20;
            const totalWidth = selectionButtons.man.w * 2 + btnMargin;
            const startX = canvas.width / 2 - totalWidth / 2;
            const btnY = canvas.height / 2 + 50;
            
            // Dimensiones de la imagen de preview
            const previewW = 30; 
            const previewH = 50; // Usar la misma altura del personaje

            // Hombre (Bot칩n Izquierdo)
            selectionButtons.man.x = startX;
            selectionButtons.man.y = btnY;
            drawButton('Hombre', selectionButtons.man.x, selectionButtons.man.y, selectionButtons.man.w, selectionButtons.man.h, '#60a5fa', '#1e40af'); // Azul
            
            // Mujer (Bot칩n Derecho)
            selectionButtons.woman.x = startX + selectionButtons.man.w + btnMargin;
            selectionButtons.woman.y = btnY;
            drawButton('Mujer', selectionButtons.woman.x, selectionButtons.woman.y, selectionButtons.woman.w, selectionButtons.woman.h, '#f472b6', '#9d174d'); // Rosa
            
            // Iconos de ejemplo de personaje debajo (USANDO IMAGENES)
            const iconY = btnY + selectionButtons.man.h + 20;
            
            // 1. Imagen Hombre preview
            if (hombreImg && hombreImg.complete) {
                ctx.drawImage(hombreImg, selectionButtons.man.x + selectionButtons.man.w / 2 - previewW / 2, iconY, previewW, previewH);
            } else {
                 // Fallback si la imagen no carga
                ctx.fillStyle = '#3b82f6'; 
                ctx.fillRect(selectionButtons.man.x + selectionButtons.man.w / 2 - previewW / 2, iconY, previewW, previewH); 
            }

            // 2. Imagen Mujer preview
            if (mujerImg && mujerImg.complete) {
                ctx.drawImage(mujerImg, selectionButtons.woman.x + selectionButtons.woman.w / 2 - previewW / 2, iconY, previewW, previewH);
            } else {
                // Fallback si la imagen no carga
                ctx.fillStyle = '#ff69b4'; 
                ctx.beginPath();
                ctx.moveTo(selectionButtons.woman.x + selectionButtons.woman.w / 2 - previewW / 2, iconY + previewH); 
                ctx.lineTo(selectionButtons.woman.x + selectionButtons.woman.w / 2, iconY); 
                ctx.lineTo(selectionButtons.woman.x + selectionButtons.woman.w / 2 + previewW / 2, iconY + previewH); 
                ctx.closePath();
                ctx.fill();
            }
        }

        // PANTALLA DE INICIO DEL JUEGO
        function drawStartScreen() {
            // ... (c칩digo para dibujar la pantalla de inicio)
            // --- T칈TULO "RUTA INVISIBLE" (IGUAL QUE SELECTION SCREEN) ---
            const titleFillStyle = '#1f2937'; // Gris oscuro/negro
            const titleStrokeStyle = 'white'; // Contorno blanco
            const titleFont = `'Arial Black', Gadget, sans-serif`;
            const titleSize = 40; // Tama침o grande

            // 1. RUTA
            drawMessage('RUTA', -160, titleSize, titleFont, titleFillStyle, titleStrokeStyle); 
            // 2. INVISIBLE
            drawMessage('INVISIBLE', -120, titleSize, titleFont, titleFillStyle, titleStrokeStyle); 
            
            // Instrucciones de inicio (manteniendo tama침o original de 24px)
            drawMessage('Toca la pantalla', 10);
            drawMessage('para EMPEZAR', 50);
            
            // Animaci칩n de inicio - El corredor s칤 se muestra aqu칤
            player.x = SIDE_AISLE_WIDTH + (canvas.width - (SIDE_AISLE_WIDTH * 2)) / 2 - player.w / 2;
            // Animaci칩n simple de movimiento lateral para la pantalla de inicio
            player.x += Math.sin(Date.now() * 0.003) * 0.5; 
            drawPlayer();
        }


        // --- L칩gica del Juego ---

        function updatePlayer() {
            // Movimiento lateral continuo (basado en las banderas isMoving)
            if (isMovingLeft) {
                player.x -= player.speedX;
            } else if (isMovingRight) {
                player.x += player.speedX;
            }

            // Limitar al jugador dentro de los bordes del canvas
            // Los l칤mites ahora incluyen el ancho del "pasillo" lateral
            player.x = Math.max(SIDE_AISLE_WIDTH, Math.min(canvas.width - player.w - SIDE_AISLE_WIDTH, player.x));
        }

        // ** FUNCI칍N generateObstacles MODIFICADA PARA ASIGNAR UN 칈NDICE DE IMAGEN **
        function generateObstacles() {
            // Generar un nuevo obst치culo basado en la constante de espaciamiento
            if (frame % OBSTACLE_GENERATION_RATE === 0) {
                // Determinar ancho y posici칩n X aleatoria
                // Los obst치culos solo aparecen en el "pasillo central"
                const playableWidth = canvas.width - (SIDE_AISLE_WIDTH * 2);
                const obsW = Math.random() * (playableWidth / 2) + 30; // Ancho entre 30 y mitad de playableWidth + 30
                const obsH = 45; // Altura de obst치culo: 45
                
                // Posici칩n X del obst치culo dentro del 치rea jugable
                let obsX = SIDE_AISLE_WIDTH + Math.random() * (playableWidth - obsW);

                // ** L칩gica para asignar el 칤ndice de imagen basado en el ancho (w) **
                let imageIndex = 1; // Default: Obst1.png (el m치s angosto)
                
                // Rangos de ancho (ajustar seg칰n sea necesario para las 4 im치genes)
                // Usamos 4 cuartiles aproximados del rango de ancho: [30, playableWidth/2 + 30]
                const minW = 30;
                const maxW = playableWidth / 2 + 30; // Ancho m치ximo
                const range = maxW - minW;
                
                if (obsW < minW + range * 0.25) {
                    imageIndex = 1; // Obst1 (m치s angosto)
                } else if (obsW < minW + range * 0.5) {
                    imageIndex = 2; // Obst2
                } else if (obsW < minW + range * 0.75) {
                    imageIndex = 3; // Obst3
                } else {
                    imageIndex = 4; // Obst4 (m치s ancho)
                }

                obstacles.push({
                    x: obsX,
                    y: -obsH, // Empieza fuera de la pantalla (arriba)
                    w: obsW,
                    h: obsH,
                    passed: false,
                    imageIndex: imageIndex // ** NUEVO: 칈ndice de la imagen a usar **
                });
            }
        }
        // ** FIN DE MODIFICACI칍N **

        function updateObstacles() {
            // Aumentar la dificultad y la velocidad progresivamente
            obstacleSpeed += gameSpeedIncrease;

            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                obs.y += obstacleSpeed; // Los obst치culos se mueven hacia abajo

                // 1. Colisi칩n (Cuadro delimitador AABB)
                if (player.x < obs.x + obs.w && 
                    player.x + player.w > obs.x &&
                    player.y < obs.y + obs.h && 
                    player.y + player.h > obs.y) {
                    gameOver();
                    return;
                }

                // 2. Puntuaci칩n: Si pasa la posici칩n Y del jugador
                if (obs.y > player.y + player.h && !obs.passed) {
                    score++;
                    obs.passed = true;
                }

                // 3. Eliminaci칩n de obst치culos: si salen por debajo de la pantalla
                if (obs.y > canvas.height) {
                    obstacles.splice(i, 1);
                }
            }
        }
        
        // Manejadores para el movimiento continuo (Touch/Click)
        function setMovement(e, isStart) {
            // Si el juego est치 cargando, ignorar todos los eventos
            if (gameState === 'loading') return;
            
            // Obtener la posici칩n del toque/clic
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const touchX = clientX - rect.left;
            const touchY = clientY - rect.top;

            // --- MANEJO DE LA PANTALLA DE SELECCI칍N DE PERSONAJE ---
            if (gameState === 'selection' && isStart) {
                
                // Bot칩n Hombre
                if (touchX >= selectionButtons.man.x && touchX <= selectionButtons.man.x + selectionButtons.man.w &&
                    touchY >= selectionButtons.man.y && touchY <= selectionButtons.man.y + selectionButtons.man.h) {
                    selectedCharacter = 'man';
                    player.image = hombreImg; // ASIGNAR LA IMAGEN
                    gameState = 'start'; // Cambiar a la pantalla de inicio
                    e.preventDefault();
                    return;
                }
                
                // Bot칩n Mujer
                if (touchX >= selectionButtons.woman.x && touchX <= selectionButtons.woman.x + selectionButtons.woman.w &&
                    touchY >= selectionButtons.woman.y && touchY <= selectionButtons.woman.y + selectionButtons.woman.h) {
                    selectedCharacter = 'woman';
                    player.image = mujerImg; // ASIGNAR LA IMAGEN
                    gameState = 'start'; // Cambiar a la pantalla de inicio
                    e.preventDefault();
                    return;
                }
                // Si est치 en la pantalla de selecci칩n y no toc칩 un bot칩n, no hacer nada.
                return;
            }
            
            // --- MANEJO DE LA PANTALLA DE INICIO (TOUCH PARA EMPEZAR) ---
            if (gameState === 'start' && isStart) {
                startGame();
                e.preventDefault();
                return;
            }


            // --- MANEJO DE LA PANTALLA DE GAME OVER ---
            if (gameState === 'gameOver' && isStart) {
                
                // 1. Detecci칩n de clic en el bot칩n REINTENTAR / JUGAR DE NUEVO (Bot칩n superior o 칰nico)
                retryBtn.w = 180; 
                retryBtn.h = 50; 
                retryBtn.x = canvas.width / 2 - retryBtn.w / 2;
                // Si score < 20, la Y es +50. Si score >= 20, la Y es +100
                retryBtn.y = score < 20 ? canvas.height / 2 + 50 : canvas.height / 2 + 100; 

                if (touchX >= retryBtn.x && 
                    touchX <= retryBtn.x + retryBtn.w &&
                    touchY >= retryBtn.y &&
                    touchY <= retryBtn.y + retryBtn.h) {
                    
                    if (score < 20) {
                        // score < 20: Reiniciar juego (Reintentar)
                        startGame();
                    } else {
                        // score >= 20: Volver a la pantalla de SELECCI칍N de personaje
                        resetGame();
                        gameState = 'selection';
                    }
                    e.preventDefault();
                    return;
                }
                
                // 2. Detecci칩n de clic en el bot칩n ACCEDE A WIFI (Solo si score >= 20)
                if (score >= 20) {
                     retryBtn.w2 = 180;
                     retryBtn.h2 = 50;  
                     retryBtn.x2 = canvas.width / 2 - retryBtn.w2 / 2;
                     retryBtn.y2 = retryBtn.y + retryBtn.h + 20; // 20px de margen
                     
                     if (touchX >= retryBtn.x2 && 
                         touchX <= retryBtn.x2 + retryBtn.w2 &&
                         touchY >= retryBtn.y2 &&
                         touchY <= retryBtn.y2 + retryBtn.h2) {
                         
                         // Redireccionar a la p치gina externa
                         window.open('https://www.metrodebogota.gov.co/', '_blank');
                         e.preventDefault();
                         return;
                     }
                }
                return;
            }


            // --- L칍GICA DE MOVIMIENTO EN ESTADO 'RUNNING' ---
            if (gameState === 'running') {
                // Previene acciones predeterminadas como el scroll
                e.preventDefault(); 
                
                // Ajuste para el nuevo 치rea jugable
                const playableXStart = SIDE_AISLE_WIDTH;
                const playableXEnd = canvas.width - SIDE_AISLE_WIDTH;

                if (touchX < playableXStart + (playableXEnd - playableXStart) / 2) {
                    // Lado izquierdo del 치rea jugable
                    isMovingLeft = isStart;
                    isMovingRight = false; 
                } else {
                    // Lado derecho del 치rea jugable
                    isMovingRight = isStart;
                    isMovingLeft = false; 
                }
                
                if (!isStart) {
                    // Si es un evento de fin (mouseup/touchend), detener todo
                    isMovingLeft = false;
                    isMovingRight = false;
                }
            }
        }
        
        function handleStart(e) { setMovement(e, true); }
        function handleMove(e) { 
            if (gameState === 'running') { // Solo permitir movimiento si el juego est치 activo
                setMovement(e, true); 
            }
        } 
        function handleEnd(e) { 
            // Esto es crucial para detener el movimiento cuando se levanta el dedo/mouse
            isMovingLeft = false;
            isMovingRight = false;
            if (e.target.tagName.toLowerCase() === 'canvas') {
                e.preventDefault();
            }
        }


        function startGame() {
            gameState = 'running';
            // El frame se reinicia en resetGame, que se llama al entrar en 'running'
            resetGame(); 
        }

        function gameOver() {
            gameState = 'gameOver';
            
            // ** SOLUCI칍N: Seleccionar el mensaje social una 칔NICA vez al perder **
            if (score < 20) {
                const randomIndex = Math.floor(Math.random() * SOCIAL_MESSAGES.length);
                gameOverMessage = SOCIAL_MESSAGES[randomIndex];
            } else {
                gameOverMessage = null; // No necesario si gan칩
            }
            
            // Asegurarse de que el movimiento se detiene al perder
            isMovingLeft = false;
            isMovingRight = false;
        }

        function resetGame() {
            // Reiniciar jugador en el centro del 치rea jugable
            player.x = SIDE_AISLE_WIDTH + (canvas.width - (SIDE_AISLE_WIDTH * 2)) / 2 - player.w / 2;
            obstacles = [];
            score = 0;
            frame = 0; // Se reinicia el contador de frames
            obstacleSpeed = 1.5; // REINICIAR VELOCIDAD a 1.5
            gameOverMessage = null; // Limpiar el mensaje de Game Over
        }

        // --- Bucle Principal del Juego (Fondo de Metro Mejorado) ---
        function loop() {
            
            // 1. DIBUJO DEL ENTORNO (Paredes, piso, techo, pasillo)
            
            // Fondo principal de las paredes laterales del vag칩n (detr치s de las sillas)
            ctx.fillStyle = VAGON_COLOR; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Piso y Techo del vag칩n
            const floorCeilingHeight = 30; // Altura del piso y techo
            ctx.fillStyle = FLOOR_CEILING_COLOR;
            ctx.fillRect(0, 0, canvas.width, floorCeilingHeight); // Techo
            ctx.fillRect(0, canvas.height - floorCeilingHeight, canvas.width, floorCeilingHeight); // Piso

            // Dibujar las "sillas" o secciones de las paredes laterales con efecto de movimiento
            const chairHeight = 60; // Altura de cada "silla"
            const chairGap = 20; // Espacio entre sillas
            const totalSectionHeight = chairHeight + chairGap;

            // Calcular el desplazamiento vertical para simular el movimiento
            // Solo se mueve si el juego est치 activo
            const verticalOffset = (gameState === 'running' ? frame * obstacleSpeed : 0) % totalSectionHeight; 

            // Lado izquierdo (Sillas Rojas)
            ctx.fillStyle = CHAIR_COLOR;
            for (let i = -1; i * totalSectionHeight + verticalOffset < canvas.height; i++) {
                const y = i * totalSectionHeight + verticalOffset;
                ctx.fillRect(0, y, SIDE_AISLE_WIDTH, chairHeight);
            }

            // Lado derecho (Sillas Rojas)
            ctx.fillStyle = CHAIR_COLOR;
            for (let i = -1; i * totalSectionHeight + verticalOffset < canvas.height; i++) {
                const y = i * totalSectionHeight + verticalOffset;
                ctx.fillRect(canvas.width - SIDE_AISLE_WIDTH, y, SIDE_AISLE_WIDTH, chairHeight);
            }

            // Dibujar el "pasillo central" con un color diferente para destacarlo (Gris claro)
            ctx.fillStyle = AISLE_COLOR; 
            ctx.fillRect(SIDE_AISLE_WIDTH, floorCeilingHeight, canvas.width - (SIDE_AISLE_WIDTH * 2), canvas.height - (floorCeilingHeight * 2));


            // 2. L칍GICA DE ESTADO Y DIBUJO ESPEC칈FICO
            switch (gameState) {
                case 'loading':
                    drawLoadingScreen();
                    break;
                    
                case 'selection':
                    drawSelectionScreen();
                    // El score no se dibuja en esta pantalla
                    break;
                    
                case 'start':
                    drawStartScreen();
                    // El score no se dibuja en esta pantalla
                    break;

                case 'running':
                    // --- JUEGO CORRIENDO ---
                    frame++;
                    generateObstacles();
                    updatePlayer();
                    updateObstacles();
                    
                    // DIBUJAR DURANTE EL JUEGO ACTIVO
                    drawObstacles();
                    drawPlayer();
                    drawScore();
                    break;

                case 'gameOver':
                    // --- Pantalla de Game Over ---
                    
                    // Umbral de Game Over especial: score < 20
                    if (score < 20) {
                        
                        // OBTENER EL MENSAJE ELEGIDO UNA SOLA VEZ AL PERDER
                        const selectedMessage = gameOverMessage;
                        
                        // 1. Cara triste (emoji)
                        ctx.fillStyle = '#fef08a'; // Amarillo claro
                        ctx.font = 'bold 60px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText('游땞', canvas.width / 2, canvas.height / 2 - 140); // Posici칩n superior
                        
                        // 2. Recuadro para el mensaje principal (gris oscuro)
                        const textRecWidth = canvas.width - 40; // Ancho ajustado
                        const textRecHeight = 100; // Aumentado para 3 l칤neas
                        const textRecX = canvas.width / 2 - textRecWidth / 2;
                        const textRecY = canvas.height / 2 - textRecHeight / 2 - 40; // Posici칩n ajustada

                        ctx.fillStyle = 'rgba(55, 65, 81, 0.8)'; // Gris oscuro (slate-700)
                        ctx.fillRect(textRecX, textRecY, textRecWidth, textRecHeight);

                        // 3. Mensaje principal (con ajuste de tama침o por l칤nea)
                        const fontStyleBlack = `'Arial Black', Gadget, sans-serif`;
                        ctx.lineWidth = 2; // Contorno m치s fino
                        
                        // L칤nea 1: 춰Vaya! (Tama침o 20px - Original)
                        drawMessage('춰Vaya!', textRecY + 25 - canvas.height/2, 20, fontStyleBlack);
                        
                        // L칤nea 2: Parece que no has conseguido (Tama침o 16px - Reducido)
                        drawMessage('Parece que no has conseguido', textRecY + 55 - canvas.height/2, 16, fontStyleBlack);
                        
                        // L칤nea 3: Superar todos los obst치culos.', textRecY + 85 - canvas.height/2, 16, fontStyleBlack);
                        drawMessage('Superar todos los obst치culos.', textRecY + 85 - canvas.height/2, 16, fontStyleBlack);

                        // 4. Bot칩n "Reintentar" (verde claro)
                        retryBtn.w = 180; 
                        retryBtn.h = 50;  
                        retryBtn.x = canvas.width / 2 - retryBtn.w / 2;
                        retryBtn.y = canvas.height / 2 + 50; // Posici칩n ajustada
                        
                        // Dibujar el bot칩n (fondo verde claro)
                        drawButton('Reintentar', retryBtn.x, retryBtn.y, retryBtn.w, retryBtn.h, '#a7f3d0', '#065f46', 28); 

                        // 5. Recuadro de texto inferior (mensaje social)
                        const boxHeight = 78; 
                        const boxY = canvas.height - boxHeight - 12; // Cerca del borde inferior
                        const padding = 10;
                        
                        // Dibujar el fondo del recuadro
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // Fondo oscuro semitransparente
                        ctx.fillRect(padding, boxY, canvas.width - (padding * 2), boxHeight);

                        // 6. Dibujar el texto del recuadro
                        if (selectedMessage) {
                            ctx.fillStyle = 'white';
                            ctx.font = '14px sans-serif'; 
                            ctx.textAlign = 'center';
                            
                            const centerX = canvas.width / 2;
                            const lineHeight = 15; // Espaciado vertical entre l칤neas
                            
                            // L칈NEA 1 (Mensaje Aleatorio - L칤nea 1)
                            ctx.fillText(selectedMessage[0], centerX, boxY + lineHeight * 2); 
                            // L칈NEA 2 (Mensaje Aleatorio - L칤nea 2)
                            ctx.fillText(selectedMessage[1], centerX, boxY + lineHeight * 3); 
                            
                            // L칈NEA 3 (Mensaje est치tico final - L칤nea 1)
                            ctx.fillText('춰Ay칰danos a que esos obst치culos solo', centerX, boxY + lineHeight * 4.5); // Espacio extra
                            // L칈NEA 4 (Mensaje est치tico final - L칤nea 2)
                            ctx.fillText('est칠n en esta pantalla!', centerX, boxY + lineHeight * 5.5); // Espacio extra
                        }


                        drawScore(); // El score se dibuja en esta pantalla
                        
                    } else {
                        // --- Pantalla de Victoria (Score >= 20) ---
                        
                        // 1. CAMBIO: Fondo Verde Oscuro
                        ctx.fillStyle = '#16a34a'; // Tailwind green-700
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // 2. CAMBIO: Icono de Celebraci칩n con animaci칩n
                        ctx.font = 'bold 70px sans-serif';
                        ctx.textAlign = 'center';
                        // Aplicamos una peque침a animaci칩n de rebote usando Math.sin(frame * 0.1)
                        const bounceY = Math.sin(frame * 0.1) * 3; // Rebota 3px
                        ctx.fillText('游봅', canvas.width / 2, canvas.height / 2 - 150 + bounceY); 

                        // 3. CAMBIO: Mensaje de Felicidades (2 l칤neas)
                        drawMessage('춰FELICIDADES!', -50, 32); // Fuente m치s grande para el t칤tulo
                        drawMessage('Superaste el reto', 0, 24);

                        // 4. Mostrar Puntaje Obtenido
                        drawMessage(`Puntaje: ${score}`, 50, 20);

                        // 5. Bot칩n 1: Jugar de Nuevo (Verde)
                        retryBtn.w = 180; 
                        retryBtn.h = 50;  
                        retryBtn.x = canvas.width / 2 - retryBtn.w / 2;
                        retryBtn.y = canvas.height / 2 + 100; // Posici칩n superior

                        // Fuente ajustada a 24px
                        // ACCI칍N: Vuelve a la pantalla de SELECCI칍N
                        drawButton('Jugar de Nuevo', retryBtn.x, retryBtn.y, retryBtn.w, retryBtn.h, '#4ade80', '#166534', 24); // Tailwind green-400 / green-800

                        // 6. Bot칩n 2: Accede a Wifi (Rojo)
                        retryBtn.w2 = 180; 
                        retryBtn.h2 = 50;  
                        retryBtn.x2 = canvas.width / 2 - retryBtn.w2 / 2;
                        retryBtn.y2 = retryBtn.y + retryBtn.h + 20; // 20px de margen entre botones
                        
                        // Fuente ajustada a 24px
                        // ACCI칍N: Abre el enlace externo
                        drawButton('Accede a Wifi', retryBtn.x2, retryBtn.y2, retryBtn.w2, retryBtn.h2, '#fca5a5', '#991b1b', 24); // Tailwind red-300 / red-800
                        
                        drawScore(); // El score se dibuja en esta pantalla
                    }
                    break;
            }

            requestAnimationFrame(loop);
        }

        // --- Eventos de Usuario (Control Continuo) ---
        
        // MOUSE/CLICK EVENTS (Simula touch para escritorio)
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove); // Permite arrastrar para mover
        document.addEventListener('mouseup', handleEnd); // Usa document para que funcione incluso si el mouse sale del canvas

        // TOUCH EVENTS (Para dispositivos m칩viles)
        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchmove', handleMove);
        document.addEventListener('touchend', handleEnd);
        
        // KEYBOARD EVENTS (Control continuo con teclas)
        document.addEventListener('keydown', (e) => {
            // No permitir entrada de teclado si el juego no ha comenzado (loading o selection)
            if (gameState === 'loading' || gameState === 'selection') return;
            
            // Permitir que el juego inicie con las flechas si est치 en la pantalla de inicio ('start')
            if (gameState === 'start') {
                if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
                    startGame();
                    return;
                }
            }
            // Control de movimiento durante el juego ('running')
            if (!document.activeElement.matches('input, button') && gameState === 'running') {
                if (e.code === 'ArrowLeft') {
                    isMovingLeft = true;
                    isMovingRight = false;
                } else if (e.code === 'ArrowRight') {
                    isMovingRight = true;
                    isMovingLeft = false;
                }
            }
            // Reiniciar con ENTER o SPACE en Game Over
            if (gameState === 'gameOver' && (e.code === 'Enter' || e.code === 'Space')) {
                 if (score < 20) {
                    startGame(); // Reintentar
                 } else if (score >= 20) {
                    // Si es victoria, el bot칩n principal (Jugar de Nuevo) vuelve a selecci칩n
                    resetGame();
                    gameState = 'selection';
                 }
            }
        });
        
        document.addEventListener('keyup', (e) => {
             if (e.code === 'ArrowLeft') {
                isMovingLeft = false;
            } else if (e.code === 'ArrowRight') {
                isMovingRight = false;
            }
        });

        // Iniciar el bucle de renderizado
        loop();
    </script>
</body>
</html>


